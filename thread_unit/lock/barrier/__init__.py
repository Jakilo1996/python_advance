# -*- coding:utf8 -*- #
# -----------------------------------------------------------------------------------
# ProjectName:   Jakiro_pro
# FileName:     __init__.py.py
# Author:      Jakiro
# Datetime:    2022/2/21 14:46
# Description:
# 命名规则  文件名小写字母+下划线，类名大驼峰，方法、变量名小写字母+下划线连接
# 常量大写，变量和常量用名词、方法用动词
# -----------------------------------------------------------------------------------



# 障碍锁 (Python Barrier对象)
# Barrier(parties, action=None, timeout=None)
# 每个线程通过调用wait()尝试通过障碍，并阻塞，直到阻塞的数量达到parties时，阻塞的线程被同时全部释放。
# action是一个可调用对象，当线程被释放时，其中一个线程会首先调用action，之后再跑自己的代码。
# timeout时默认的超时时间。
#
# 方法：
# wait(timeout=None)
# 尝试通过障碍并阻塞。
# 返回值是一个在0到parties-1范围内的整数，每个线程都不同。
# 其中一个线程在释放之前将调用action。如果此调用引发错误，则障碍将进入断开状态。
# 如果等待超时，障碍也将进入断开状态。
# 如果在线程等待期间障碍断开或重置，此方法可能会引发BrokenBarrierError错误。
#
# reset()
# 重置障碍，返回默认的空状态，即当前阻塞的线程重新来过。见例二
#
# abort()
# 将障碍置为断开状态，这将导致已调用wait()或之后调用wait()引发BrokenBarrierError。见例三
#
# 属性：
# partier
# 通过障碍所需的线程数。
#
# n_waiting
# 当前在屏障中等待的线程数
#
# broken
# 如果屏障处于断开状态，则返回True。
#
# 总结:障碍锁也是线程之间共享的，可以阻塞一个或者多个线程，不同的是，当阻塞的线程达到一个目标值以后
# ，被阻塞的线程会被同时释放，提供了action，在达到目标值以后会执行此action可调用对象（用户自定义函数），且只执行一次。
#