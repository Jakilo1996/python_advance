# -*- coding:utf8 -*- #
# -----------------------------------------------------------------------------------
# ProjectName:   Jakiro_pro
# FileName:     condition.py
# Author:      Jakiro
# Datetime:    2022/2/18 15:48
# Description:
# 命名规则  文件名小写字母+下划线，类名大驼峰，方法、变量名小写字母+下划线连接
# 常量大写，变量和常量用名词、方法用动词
# -----------------------------------------------------------------------------------

# 条件锁  （Python Condition(条件对象)
# 条件变量允许一个或多个线程等待，直到他们被另一个线程通知。
#
# 方法：
#
# acquire(*args)
# 获取锁。这个方法调用底层锁的相应方法。
#
# release()
# 释放锁。这个方法调用底层锁的相应方法。
#
# wait(timeout=None)
# 线程挂起，等待被唤醒(其他线程的notify方法)或者发生超时。调用该方法的线程必须先获得锁，否则引发RuntimeError。
# 该方法会释放底层锁，然后阻塞，直到它被另一个线程中的相同条件变量的notify()或notify_all()方法唤醒，或者发生超时。一旦被唤醒或超时，它会重新获取锁并返回。
# 返回值为True，如果给定timeout并发生超时，则返回False。
#
# wait_for(predicate, timeout=None)
# 等待知道条件变量的返回值为True。predicate应该是一个返回值可以解释为布尔值的可调用对象。可以设置timeout以给定最大等待时间。
# 该方法可以重复调用wait()，直到predicate的返回值解释为True，或发生超时。该方法的返回值就是predicate的最后一个返回值，如果发生超时，返回值为False。
# 如果忽略超时功能，该方法大致相当于：
#
# 它与wait()的规则相同：调用前必须先获取锁，阻塞时释放锁，并在被唤醒时重新获取锁并返回。
#
# notify(n=1)
# 默认情况下，唤醒等待此条件变量的一个线程(如果有)。调用该方法的线程必须先获得锁，否则引发RuntimeError。
# 该方法最多唤醒n个等待中的线程，如果没有线程在等待，它就是要给无动作的操作。
# 注意：要被唤醒的线程实际上不会马上从wait()方法返回(唤醒)，而是等到它重新获取锁。这是因为notify()并不会释放锁，需要线程本身来释放(通过wait()或者release())
#
# notify_all()
# 此方法类似于notify()，但唤醒的时所有等待的线程。

#
#
# 实例


