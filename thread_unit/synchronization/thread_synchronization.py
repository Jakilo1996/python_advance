# -*- coding:utf8 -*- #
# -----------------------------------------------------------------------------------
# ProjectName:   Jakiro_pro
# FileName:     thread_synchronization.py
# Author:      Jakiro
# Datetime:    2022/2/18 13:32
# Description:
# 命名规则  文件名小写字母+下划线，类名大驼峰，方法、变量名小写字母+下划线连接
# 常量大写，变量和常量用名词、方法用动词
# -----------------------------------------------------------------------------------

# 线程安全
# 多线程主要是为了提高我们cpu的资源使用率。但同时，这会给我们带来很多安全问题！
#
# 如果我们在单线程中以“顺序”(串行-->独占)的方式执行代码是没有任何问题的。但是到了多线程的环境下(并行)，如果没有设计和控制得好，就会给我们带来很多意想不到的状况，也就是线程安全性问题。
#
# 因为在多线程的环境下，线程是交替执行的，一般他们会使用多个线程执行相同的代码。如果在此相同的代码里边有着共享的变量，或者一些组合操作（访问共享的内存），我们想要的正确结果就很容易出现了问题。
#
# 那么到底什么是线程安全呢？
#
# 线程安全的问题在于多个线程访问共享的内存而产生的，也就是我们要确保在多线程访问的时候，我们的程序还能按照我们预期的行为去执行，这句话里最重要的是多线程，共享内存，你现在要记住这两句话。

from threading import Thread

num = 0


def add_num():
    global num
    for i in range(100000):
        num += 1


if __name__ == '__main__':
    threads = []  # 创建进程列表
    for i in range(0, 10):
        t = Thread(target=add_num)
        t.start()
        threads.append(t)
    # 主线程等待所有子线程运行结束
    for thread in threads:
        thread.join()
    print(num)

# 首先，它共享了num这个变量，其次来说num+=1这个操作来说;这是一个组合的操作(注意，它并非是原子性）
#
# 实际上的操作是这样子的：
#
# 1.读取num 值
# 2.将值+1
# 3.将计算结果写入num
#
# 于是多线程执行的时候很可能就会有这样的情况：
#
# 如果当线程A读取到num 的值是8的时候，同时线程B也进去这个方法上了，也是读取到num 的值为8
#
# 它俩都对值进行加1
#
# 都将计算结果写入到num上。但是，写入到num上的结果是9
#
# 也就是说：两个线程进来了，但是正确的结果是应该返回10，而它返回了9，这是错误的，而我们希望的是num的值为10。
#
# 如果说：当多个线程访问某个类的时候，这个类始终能表现出正确的行为，那么这个类就是线程安全的！





